PL/SQL
Procedural language extension to Structured Query Language(SQL)의 약자
SQL을 확장한 순차적 처리 언어

PL/SQL의 기본 구조
익명 블럭
1)선언부(declarative part) : 사용할 변수나 상수를 선언(선언부에만 변수와 상수 선언 가능)
2)실행부(executable part) : 실제 처리할 로직을 담당하는 부분
3)예외처리부(exception-building part) : 실행부에서 로직을 처리하던 중 발생할 수 있는 각종 오류들에 대해 처리

기본 구조--오라클 콘솔에 출력 dbms_output_line();  ex) 이클립스에서 system.out.println();

begin
    --실행부
    dbms_output.put_line('Hello World');
end;


declare
    --변수를 선언 할 수 있는 선언부
    message varchar2(100);
begin
    --실행부에 사용할 변수는 선언부에서 미리 선언되어야 함
    message :='Hello Oracle'; --message 뒤에 들어갈 대입 연산자 : ':='
    dbms_output.put_line(message);
end;


declare
    message varchar2(100) := 'Hello PL/SQL';
begin
    dbms_output.put_line(message);
end;


declare
    counter integer; --대입을 하지 않으면 counter 는 null
begin
    counter := counter + 1; --> null + 1 = null
    if counter is null then --null이면 true null이 아니면 false
    dbms_output.put_line('Result : counter is null');
    end if;
end;


declare
    --변수 선언
    counter integer;
    i integer;
begin
    --반복문
    for i in 1..9 loop --for  loop 사이에서 조건체크
        counter := 2 * i;
        dbms_output.put_line('2 * ' || i || ' = ' || counter);
    end loop;
end;

예외처리부 사용

declare
    counter integer;
begin
    counter := 10;
    counter := counter/0;
    dbms_output.put_line(counter);
    
    exception when others then
        dbms_output.put_line('errors');
end;

콜렉션
varray는 variable array의 약자로 고정 길이(fixed number)를 가진 배열

declare
    type varray_test is varray(3) of integer;
    varray1 varray_test; --위에서 선언한 varray_test 타입 변수
begin
    varray1 := varray_test(10,20,30);
    
    dbms_output.put_line(varray1(1));
    dbms_output.put_line(varray1(2));
    dbms_output.put_line(varray1(3));
end;

중첩 테이블
중첩 테이블은 varray와 흡사하지만 중첩 테이블은 선언 시에 전체 크기를 명시할 필요가 없다

declare
    type nested_test is table of varchar2(10);
    nested1 nested_test; --위에 선언한 nested_test 타입의 변수
begin
    nested1 := nested_test('A','B','C','D');
    
    dbms_output.put_line(nested1(2));
end;

연관배열(Associative Array) : index-by table이라고도 하며 키와 값의 쌍으로 구성된 콜렉션, 하나의 키는 하나의 값과 연관되어 있다.

declare
    type assoc_array is table of number index by pls_integer;
    --키는 pls_integer형이며, 값은 number형인 요소들로 구성
    assoc1 assoc_array;
begin
    assoc1(3) := 33; --키는 3, 값은 33
    dbms_output.put_line(assoc1(3));
end;

레코드
테이블의 컬럼들이 서로 다른 유형의 데이터 타입으로 구성되듯이 레코드 역시 해당 필드들이 각기 다른 데이터 타입을 가질 수 있음

declare
    type record1 is record(deptno number,dname varchar2(14),loc varchar2(13));
    rec1 record1; --위에서 선언한 record1을 받는 변수 선언
begin
    rec1.deptno := 50;
    rec1.dname := 'RECORD';
    rec1.loc := 'SEOUL';
    
    --rec1 레코드값을 dept 테이블에 insert
    INSERT INTO dept VALUES rec1;
    COMMIT;

    exception when others then
        ROLLBACK;
end;

if문

declare
    grade char(1); 
begin
    grade := 'B';
    if grade = 'A' then
   dbms_output.put_line('Execllent');
   elsif grade = 'B' then
   dbms_output.put_line('Good');
   elsif grade = 'C' then
   dbms_output.put_line('Fair');
   elsif grade = 'D' then
   dbms_output.put_line('Poor');
   end if;
end;

case문

declare
    grade char(1);
begin
    grade := 'B';
    
    case grade
    when 'A' then
    dbms_output.put_line('Excellent');
    when 'B' then
    dbms_output.put_line('Good');
    when 'C' then
    dbms_output.put_line('Fair');
    when 'D' then
    dbms_output.put_line('Poor');
    end case;
end;

loop문

declare
    test_number integer;
    result_num integer;
begin
    test_number := 1;
    
    loop
        result_num := 2 * test_number;
        if result_num > 20 then
            exit; -- 블록 종료
        else
            dbms_output.put_line(result_num);
            end if;
            
            test_number := test_number + 1;
    end loop;
    --loop 블럭을 빠져나오면 아래 코드를 실행함
    dbms_output.put_line('프로그램 끝');
end;

declare
    test_number integer;
    result_num integer;
begin
    test_number := 1;
    
    loop
        result_num := 2 * test_number;
        
        exit when result_num >20;
        
        dbms_output.put_line(result_num);
        test_number := test_number + 1;
    end loop;
end;


while-loop문

declare
    test_number integer;
    result_num integer;
begin
    test_number := 1;
    result_num := 0;
    
    while result_num < 20 loop
        result_num := 2 * test_number;
        dbms_output.put_line(result_num);
        test_number := test_number + 1;
    end loop;   
end;

for loop문

declare
    test_number integer;
    result_num integer;
begin
    
    for test_number in 1..10 loop
        result_num := 2 * test_number;
        dbms_output.put_line(result_num);
    end loop;
end;

--반대로 출력되게 하려면 in reverse
declare
    test_number integer;
    result_num integer;
begin
    
    for test_number in reverse 1..10 loop
        result_num := 2 * test_number;
        dbms_output.put_line(result_num);
    end loop;
end;

커서
SELECT 문장을 실행하면 조건에 따른 결과가 추출된다.
추출되는 결과는 한 건이 될 수도 있고 여러 건이 될 수도 있으므로 이를 결과 셋(Result Set)혹은 결과 집합이라고 부르기도 한다.
쿼리에 의해 반환되는 결과는 메모리 상에 위치하게 되는데 PL/SQL에서는 바로 커서(CURSOR)를 사용하여 이 결과집합에 접근할 수 있다.
즉, 커서를 사용하면 결과집합의 각 개별 데이터에 접근이 가능.

declare
    cursor emp_csr is
    SELECT empno
    FROM emp
    WHERE deptno=10;
    
    emp_no emp.empno%type;
begin
    --커서 열기 : 커서로 정의된 커리를 실행하는 역할
    open emp_csr;
    
    loop
        fetch emp_csr into emp_no; --커서를 이용해서 행에 접근. 컬럼값을 emp_no에 할당(fetch 역할)
        --%notfound : 커서에서만 사용 가능한 속성
        --더 이상 패치(할당)할 로우가 없음을 의미
        exit when emp_csr%notfound;
        
        dbms_output.put_line(emp_no);
    end loop;
    close emp_csr;
end;

함수

입력받은 값으로부터 10%의 세율을 얻는 함수
create or replace function tax(p_value in number)
    return number
is begin
    return p_value * 0.1; 
end;

SELECT TAX(100) FROM dual;
SELECT ename,sal,TAX(sal) tax, sal-TAX(sal) "실지급 급여" FROM emp;

급여와 커미션을 합쳐서 세금 계산
create or replace function tax2(p_sal in emp.sal%type, p_bonus emp.comm%type) --p_bonus 뒤에 in 생략
    return number
is
begin
    return (p_sal + NVL(p_bonus,0)) * 0.1; 
end;

SELECT empno,ename,sal,comm,TAX2(sal,comm) AS tax FROM emp;

급여(커미션 포함)에 대한 세율을 다음과 같이 정의함. 급여가 월 $1,000보다 적으면
세율을 5% 적용하며, $1,000이상 $2,000이하이면 10%, $2,000을 초과하면 20%를 적용
create or replace function tax3(p_sal emp.sal%type, p_bonus emp.comm%type)
    return number
is
    e_sum number;
    e_tax number;
begin
    e_sum := p_sal + NVL(p_bonus,0);
    
    if e_sum < 1000 then
        e_tax := e_sum * 0.05;
    elsif e_sum <= 2000 then
        e_tax := e_sum * 0.1;
    else
        e_tax := e_sum * 0.2;
    end if;
    
    return e_tax;
end;

SELECT empno,ename,sal,comm,TAX3(sal,comm) AS tax FROM emp;

사원번호를 통해서 급여를 알려주는 함수
create or replace function emp_salaries(emp_no number)
    return number
is
    nSalaries number(9);
begin
    nSalaries := 0;
    SELECT sal
    -- 결과행이 단일행일 경우 INTO를 이용해서 읽어온 값을 변수에 담을 수 있음.
    INTO nSalaries
    FROM emp
    WHERE empno =emp_no;
    
    return nSalaries;
end;

SELECT EMP_SALARIES(7839) FROM dual; --emp로하면 중복값 모두 나옴, dual 로 해야됨
SELECT EMP_SALARIES(9000) FROM dual; --없는 사원번호를 입력하면 NULL반환